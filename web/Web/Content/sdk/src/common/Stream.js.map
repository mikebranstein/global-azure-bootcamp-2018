{"version":3,"sources":["../src/common/Stream.ts"],"names":[],"mappings":"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","file":"Stream.js","sourcesContent":["import { InvalidOperationError } from \"./Error\";\nimport { CreateNoDashGuid } from \"./Guid\";\nimport { IStringDictionary } from \"./IDictionary\";\nimport { Promise } from \"./Promise\";\nimport { Queue } from \"./Queue\";\nimport { IStreamChunk } from \"./Stream\";\n\nexport interface IStreamChunk<TBuffer> {\n    IsEnd: boolean;\n    Buffer: TBuffer;\n}\n\nexport class Stream<TBuffer> {\n    private id: string;\n    private readerIdCounter: number = 1;\n    private streambuffer: Array<IStreamChunk<TBuffer>>;\n    private isEnded: boolean = false;\n    private readerQueues: IStringDictionary<Queue<IStreamChunk<TBuffer>>>;\n\n    public constructor(streamId?: string) {\n        this.id = streamId ? streamId : CreateNoDashGuid();\n        this.streambuffer = [];\n        this.readerQueues = {};\n    }\n\n    public get IsClosed(): boolean {\n        return this.isEnded;\n    }\n\n    public get Id(): string {\n        return this.id;\n    }\n\n    public Write = (buffer: TBuffer): void => {\n        this.ThrowIfClosed();\n        this.WriteStreamChunk({\n            Buffer: buffer,\n            IsEnd: false,\n        });\n    }\n\n    public GetReader = (): StreamReader<TBuffer> => {\n        const readerId = this.readerIdCounter;\n        this.readerIdCounter++;\n        const readerQueue = new Queue<IStreamChunk<TBuffer>>();\n        const currentLength = this.streambuffer.length;\n        this.readerQueues[readerId] = readerQueue;\n        for (let i = 0; i < currentLength; i++) {\n            readerQueue.Enqueue(this.streambuffer[i]);\n        }\n        return new StreamReader(\n            this.id,\n            readerQueue,\n            () => {\n                delete this.readerQueues[readerId];\n            });\n    }\n\n    public Close = (): void => {\n        if (!this.isEnded) {\n            this.WriteStreamChunk({\n                Buffer: null,\n                IsEnd: true,\n            });\n            this.isEnded = true;\n        }\n    }\n\n    private WriteStreamChunk = (streamChunk: IStreamChunk<TBuffer>): void => {\n        this.ThrowIfClosed();\n        this.streambuffer.push(streamChunk);\n        for (const readerId in this.readerQueues) {\n            if (!this.readerQueues[readerId].IsDisposed()) {\n                try {\n                    this.readerQueues[readerId].Enqueue(streamChunk);\n                } catch (e) {\n                    // Do nothing\n                }\n            }\n        }\n    }\n\n    private ThrowIfClosed = (): void => {\n        if (this.isEnded) {\n            throw new InvalidOperationError(\"Stream closed\");\n        }\n    }\n}\n\n// tslint:disable-next-line:max-classes-per-file\nexport class StreamReader<TBuffer> {\n    private readerQueue: Queue<IStreamChunk<TBuffer>>;\n    private onClose: () => void;\n    private isClosed: boolean = false;\n    private streamId: string;\n\n    public constructor(streamId: string, readerQueue: Queue<IStreamChunk<TBuffer>>, onClose: () => void) {\n        this.readerQueue = readerQueue;\n        this.onClose = onClose;\n        this.streamId = streamId;\n    }\n\n    public get IsClosed(): boolean {\n        return this.isClosed;\n    }\n\n    public get StreamId(): string {\n        return this.streamId;\n    }\n\n    public Read = (): Promise<IStreamChunk<TBuffer>> => {\n        if (this.IsClosed) {\n            throw new InvalidOperationError(\"StreamReader closed\");\n        }\n\n        return this.readerQueue\n            .Dequeue()\n            .OnSuccessContinueWith((streamChunk: IStreamChunk<TBuffer>) => {\n                if (streamChunk.IsEnd) {\n                    this.readerQueue.Dispose(\"End of stream reached\");\n                }\n\n                return streamChunk;\n            });\n    }\n\n    public Close = (): void => {\n        if (!this.isClosed) {\n            this.isClosed = true;\n            this.readerQueue.Dispose(\"StreamReader closed\");\n            this.onClose();\n        }\n    }\n}\n"]}