{"version":3,"sources":["../src/common.browser/FileAudioSource.ts"],"names":[],"mappings":"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","file":"FileAudioSource.js","sourcesContent":["import {\n    AudioSourceErrorEvent,\n    AudioSourceEvent,\n    AudioSourceInitializingEvent,\n    AudioSourceOffEvent,\n    AudioSourceReadyEvent,\n    AudioStreamNodeAttachedEvent,\n    AudioStreamNodeAttachingEvent,\n    AudioStreamNodeDetachedEvent,\n    AudioStreamNodeErrorEvent,\n    CreateNoDashGuid,\n    Events,\n    EventSource,\n    IAudioSource,\n    IAudioStreamNode,\n    IStringDictionary,\n    PlatformEvent,\n    Promise,\n    PromiseHelper,\n    Stream,\n    StreamReader,\n} from \"../common/Exports\";\n\nimport { Timer } from \"../common.browser/Exports\";\n\nexport class FileAudioSource implements IAudioSource {\n\n    // Recommended sample rate (bytes/second).\n    private static readonly SAMPLE_RATE: number = 16000 * 2; // 16 kHz * 16 bits\n\n    // We should stream audio at no faster than 2x real-time (i.e., send five chunks\n    // per second, with the chunk size == sample rate in bytes per second * 2 / 5).\n    private static readonly CHUNK_SIZE: number = FileAudioSource.SAMPLE_RATE * 2 / 5;\n\n    private static readonly UPLOAD_INTERVAL: number = 200; // milliseconds\n\n    // 10 seconds of audio in bytes =\n    // sample rate (bytes/second) * 600 (seconds) + 44 (size of the wave header).\n    private static readonly MAX_SIZE: number = FileAudioSource.SAMPLE_RATE * 600 + 44;\n\n    private streams: IStringDictionary<Stream<ArrayBuffer>> = {};\n\n    private id: string;\n\n    private events: EventSource<AudioSourceEvent>;\n\n    private file: File;\n\n    public constructor(file: File, audioSourceId?: string) {\n        this.id = audioSourceId ? audioSourceId : CreateNoDashGuid();\n        this.events = new EventSource<AudioSourceEvent>();\n        this.file = file;\n    }\n\n    public TurnOn = (): Promise<boolean> => {\n        if (typeof FileReader === \"undefined\") {\n            const errorMsg = \"Browser does not support FileReader.\";\n            this.OnEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // initialization error - no streamid at this point\n            return PromiseHelper.FromError<boolean>(errorMsg);\n        } else if (this.file.name.lastIndexOf(\".wav\") !== this.file.name.length - 4) {\n            const errorMsg = this.file.name + \" is not supported. Only WAVE files are allowed at the moment.\";\n            this.OnEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\n            return PromiseHelper.FromError<boolean>(errorMsg);\n        } else if (this.file.size > FileAudioSource.MAX_SIZE) {\n            const errorMsg = this.file.name + \" exceeds the maximum allowed file size (\" + FileAudioSource.MAX_SIZE + \").\";\n            this.OnEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\n            return PromiseHelper.FromError<boolean>(errorMsg);\n        }\n\n        this.OnEvent(new AudioSourceInitializingEvent(this.id)); // no stream id\n        this.OnEvent(new AudioSourceReadyEvent(this.id));\n        return PromiseHelper.FromResult(true);\n    }\n\n    public Id = (): string => {\n        return this.id;\n    }\n\n    public Attach = (audioNodeId: string): Promise<IAudioStreamNode> => {\n        this.OnEvent(new AudioStreamNodeAttachingEvent(this.id, audioNodeId));\n\n        return this.Upload(audioNodeId).OnSuccessContinueWith<IAudioStreamNode>(\n            (streamReader: StreamReader<ArrayBuffer>) => {\n                this.OnEvent(new AudioStreamNodeAttachedEvent(this.id, audioNodeId));\n                return {\n                    Detach: () => {\n                        streamReader.Close();\n                        delete this.streams[audioNodeId];\n                        this.OnEvent(new AudioStreamNodeDetachedEvent(this.id, audioNodeId));\n                        this.TurnOff();\n                    },\n                    Id: () => {\n                        return audioNodeId;\n                    },\n                    Read: () => {\n                        return streamReader.Read();\n                    },\n                };\n            });\n    }\n\n    public Detach = (audioNodeId: string): void => {\n        if (audioNodeId && this.streams[audioNodeId]) {\n            this.streams[audioNodeId].Close();\n            delete this.streams[audioNodeId];\n            this.OnEvent(new AudioStreamNodeDetachedEvent(this.id, audioNodeId));\n        }\n    }\n\n    public TurnOff = (): Promise<boolean> => {\n        for (const streamId in this.streams) {\n            if (streamId) {\n                const stream = this.streams[streamId];\n                if (stream && !stream.IsClosed) {\n                    stream.Close();\n                }\n            }\n        }\n\n        this.OnEvent(new AudioSourceOffEvent(this.id)); // no stream now\n        return PromiseHelper.FromResult(true);\n    }\n\n    public get Events(): EventSource<AudioSourceEvent> {\n        return this.events;\n    }\n\n    private Upload = (audioNodeId: string): Promise<StreamReader<ArrayBuffer>> => {\n        return this.TurnOn()\n            .OnSuccessContinueWith<StreamReader<ArrayBuffer>>((_: boolean) => {\n                const stream = new Stream<ArrayBuffer>(audioNodeId);\n\n                this.streams[audioNodeId] = stream;\n\n                const reader: FileReader = new FileReader();\n\n                let startOffset = 0;\n                let endOffset = FileAudioSource.CHUNK_SIZE;\n                let lastWriteTimestamp = 0;\n\n                const processNextChunk = (event: Event): void => {\n                    if (stream.IsClosed) {\n                        return; // output stream was closed (somebody called TurnOff). We're done here.\n                    }\n\n                    if (lastWriteTimestamp !== 0) {\n                        const delay = Date.now() - lastWriteTimestamp;\n                        if (delay < FileAudioSource.UPLOAD_INTERVAL) {\n                            // It's been less than the \"upload interval\" since we've uploaded the\n                            // last chunk. Schedule the next upload to make sure that we're sending\n                            // upstream roughly one chunk per upload interval.\n                            new Timer(FileAudioSource.UPLOAD_INTERVAL - delay, processNextChunk).start();\n                            return;\n                        }\n                    }\n\n                    stream.Write(reader.result);\n                    lastWriteTimestamp = Date.now();\n\n                    if (endOffset < this.file.size) {\n                        startOffset = endOffset;\n                        endOffset = Math.min(endOffset + FileAudioSource.CHUNK_SIZE, this.file.size);\n                        const chunk = this.file.slice(startOffset, endOffset);\n                        reader.readAsArrayBuffer(chunk);\n                    } else {\n                        // we've written the entire file to the output stream, can close it now.\n                        stream.Close();\n                    }\n                };\n\n                reader.onload = processNextChunk;\n\n                reader.onerror = (event: ErrorEvent) => {\n                    const errorMsg = `Error occurred while processing '${this.file.name}'. ${event.error}`;\n                    this.OnEvent(new AudioStreamNodeErrorEvent(this.id, audioNodeId, event.error));\n                    throw new Error(errorMsg);\n                };\n\n                const chunk = this.file.slice(startOffset, endOffset);\n                reader.readAsArrayBuffer(chunk);\n\n                return stream.GetReader();\n            });\n    }\n\n    private OnEvent = (event: AudioSourceEvent): void => {\n        this.events.OnEvent(event);\n        Events.Instance.OnEvent(event);\n    }\n}\n"]}