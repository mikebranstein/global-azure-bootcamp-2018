{"version":3,"sources":["../src/common.browser/OpusRecorder.ts"],"names":[],"mappings":";;AAMA;IAII,sBAAY,OAAqD;QAAjE,iBAEC;QAEM,WAAM,GAAG,UAAC,OAAqB,EAAE,WAAwB,EAAE,YAAiC;YAC/F,IAAM,aAAa,GAAQ,IAAI,aAAa,CAAC,WAAW,EAAE,KAAI,CAAC,oBAAoB,CAAC,CAAC;YACrF,IAAM,SAAS,GAAG,GAAG,CAAC,CAAC,2GAA2G;YAClI,aAAa,CAAC,eAAe,GAAG,UAAC,kBAAuB;gBACpD,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;oBACf,IAAM,QAAM,GAAG,IAAI,UAAU,EAAE,CAAC;oBAChC,QAAM,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;oBAClD,QAAM,CAAC,SAAS,GAAG,UAAC,KAAoB;wBACpC,YAAY,CAAC,KAAK,CAAC,QAAM,CAAC,MAAM,CAAC,CAAC;oBACtC,CAAC,CAAC;gBACN,CAAC;YACL,CAAC,CAAC;YAEF,KAAI,CAAC,cAAc,GAAG;gBAClB,QAAQ,EAAE,aAAa;gBACvB,MAAM,EAAE,WAAW;aACtB,CAAC;YACF,aAAa,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACnC,CAAC,CAAA;QAEM,0BAAqB,GAAG,UAAC,OAAqB;YACjD,EAAE,CAAC,CAAC,KAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC;gBACpD,KAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;YACxC,CAAC;YACD,KAAI,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,UAAC,KAAU,IAAK,OAAA,KAAK,CAAC,IAAI,EAAE,EAAZ,CAAY,CAAC,CAAC;QACjF,CAAC,CAAA;QA5BG,IAAI,CAAC,oBAAoB,GAAG,OAAO,CAAC;IACxC,CAAC;IA4BL,mBAAC;AAAD,CAlCA,AAkCC,IAAA;AAlCY,oCAAY;AAyCzB;;;;;;;;GAQG","file":"OpusRecorder.js","sourcesContent":["import { Stream } from \"../common/Exports\";\nimport { IRecorder } from \"./IRecorder\";\n\n// getting around the build error for MediaRecorder as Typescript does not have a definition for this one.\ndeclare var MediaRecorder: any;\n\nexport class OpusRecorder implements IRecorder {\n    private mediaResources: IMediaResources;\n    private mediaRecorderOptions: any;\n\n    constructor(options?: { mimeType: string, bitsPerSecond: number }) {\n        this.mediaRecorderOptions = options;\n    }\n\n    public Record = (context: AudioContext, mediaStream: MediaStream, outputStream: Stream<ArrayBuffer>): void => {\n        const mediaRecorder: any = new MediaRecorder(mediaStream, this.mediaRecorderOptions);\n        const timeslice = 100; // this is in ms - 100 ensures that the chunk doesn't exceed the max size of chunk allowed in WS connection\n        mediaRecorder.ondataavailable = (dataAvailableEvent: any) => {\n            if (outputStream) {\n                const reader = new FileReader();\n                reader.readAsArrayBuffer(dataAvailableEvent.data);\n                reader.onloadend = (event: ProgressEvent) => {\n                    outputStream.Write(reader.result);\n                };\n            }\n        };\n\n        this.mediaResources = {\n            recorder: mediaRecorder,\n            stream: mediaStream,\n        };\n        mediaRecorder.start(timeslice);\n    }\n\n    public ReleaseMediaResources = (context: AudioContext): void => {\n        if (this.mediaResources.recorder.state !== \"inactive\") {\n            this.mediaResources.recorder.stop();\n        }\n        this.mediaResources.stream.getTracks().forEach((track: any) => track.stop());\n    }\n}\n\ninterface IMediaResources {\n    stream: MediaStream;\n    recorder: any;\n}\n\n/* Declaring this inline to avoid compiler warnings\ndeclare class MediaRecorder {\n    constructor(mediaStream: MediaStream, options: any);\n\n    public state: string;\n\n    public ondataavailable(dataAvailableEvent: any): void;\n    public stop(): void;\n}*/\n"]}