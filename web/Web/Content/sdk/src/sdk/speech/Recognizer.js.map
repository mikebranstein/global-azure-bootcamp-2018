{"version":3,"sources":["../src/sdk/speech/Recognizer.ts"],"names":[],"mappings":"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","file":"Recognizer.js","sourcesContent":["import {\n    ArgumentNullError,\n    ConnectionMessage,\n    ConnectionOpenResponse,\n    ConnectionState,\n    CreateNoDashGuid,\n    Deferred,\n    Events,\n    IAudioSource,\n    IAudioStreamNode,\n    IConnection,\n    IDetachable,\n    IEventSource,\n    IStreamChunk,\n    MessageType,\n    PlatformEvent,\n    Promise,\n    PromiseHelper,\n    PromiseResult,\n} from \"../../common/Exports\";\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\nimport { IConnectionFactory } from \"./IConnectionFactory\";\nimport {\n    ConnectingToServiceEvent,\n    ListeningStartedEvent,\n    RecognitionCompletionStatus,\n    RecognitionEndedEvent,\n    RecognitionStartedEvent,\n    RecognitionTriggeredEvent,\n    SpeechDetailedPhraseEvent,\n    SpeechEndDetectedEvent,\n    SpeechFragmentEvent,\n    SpeechHypothesisEvent,\n    SpeechRecognitionEvent,\n    SpeechRecognitionResultEvent,\n    SpeechSimplePhraseEvent,\n    SpeechStartDetectedEvent,\n} from \"./RecognitionEvents\";\nimport { RecognitionMode, RecognizerConfig, SpeechResultFormat } from \"./RecognizerConfig\";\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nimport {\n    IDetailedSpeechPhrase,\n    ISimpleSpeechPhrase,\n    ISpeechEndDetectedResult,\n    ISpeechFragment,\n    ISpeechStartDetectedResult,\n} from \"./SpeechResults\";\n\nexport class Recognizer {\n    private authentication: IAuthentication;\n    private connectionFactory: IConnectionFactory;\n    private audioSource: IAudioSource;\n    private recognizerConfig: RecognizerConfig;\n    private speechConfigConnectionId: string;\n    private connectionFetchPromise: Promise<IConnection>;\n    private connectionId: string;\n    private authFetchEventId: string;\n\n    public constructor(\n        authentication: IAuthentication,\n        connectionFactory: IConnectionFactory,\n        audioSource: IAudioSource,\n        recognizerConfig: RecognizerConfig) {\n\n        if (!authentication) {\n            throw new ArgumentNullError(\"authentication\");\n        }\n\n        if (!connectionFactory) {\n            throw new ArgumentNullError(\"connectionFactory\");\n        }\n\n        if (!audioSource) {\n            throw new ArgumentNullError(\"audioSource\");\n        }\n\n        if (!recognizerConfig) {\n            throw new ArgumentNullError(\"recognizerConfig\");\n        }\n\n        this.authentication = authentication;\n        this.connectionFactory = connectionFactory;\n        this.audioSource = audioSource;\n        this.recognizerConfig = recognizerConfig;\n    }\n\n    public get AudioSource(): IAudioSource {\n        return this.audioSource;\n    }\n\n    public Recognize = (onEventCallback: (event: SpeechRecognitionEvent) => void, speechContextJson?: string): Promise<boolean> => {\n        const requestSession = new RequestSession(this.audioSource.Id(), onEventCallback);\n        requestSession.ListenForServiceTelemetry(this.audioSource.Events);\n\n        return this.audioSource\n            .Attach(requestSession.AudioNodeId)\n            .ContinueWithPromise<boolean>((result: PromiseResult<IAudioStreamNode>) => {\n                if (result.IsError) {\n                    requestSession.OnAudioSourceAttachCompleted(null, true, result.Error);\n                    throw new Error(result.Error);\n                } else {\n                    requestSession.OnAudioSourceAttachCompleted(result.Result, false);\n                }\n\n                const audioNode = result.Result;\n\n                this.FetchConnection(requestSession)\n                    .OnSuccessContinueWith((connection: IConnection) => {\n                        const messageRetrievalPromise = this.ReceiveMessage(connection, requestSession);\n                        const messageSendPromise = this.SendSpeechConfig(requestSession.RequestId, connection, this.recognizerConfig.SpeechConfig.Serialize())\n                            .OnSuccessContinueWithPromise((_: boolean) => {\n                                return this.SendSpeechContext(requestSession.RequestId, connection, speechContextJson)\n                                    .OnSuccessContinueWithPromise((_: boolean) => {\n                                        return this.SendAudio(requestSession.RequestId, connection, audioNode, requestSession);\n                                    });\n                            });\n\n                        const completionPromise = PromiseHelper.WhenAll([messageRetrievalPromise, messageSendPromise]);\n\n                        completionPromise.On((r: boolean) => {\n                            requestSession.Dispose();\n                            this.SendTelemetryData(requestSession.RequestId, connection, requestSession.GetTelemetry());\n                        }, (error: string) => {\n                            requestSession.Dispose(error);\n                            this.SendTelemetryData(requestSession.RequestId, connection, requestSession.GetTelemetry());\n                        });\n\n                        return completionPromise;\n                    });\n\n                return requestSession.CompletionPromise;\n            });\n    }\n\n    private FetchConnection = (requestSession: RequestSession, isUnAuthorized: boolean = false): Promise<IConnection> => {\n        if (this.connectionFetchPromise) {\n            if (this.connectionFetchPromise.Result().IsError\n                || this.connectionFetchPromise.Result().Result.State() === ConnectionState.Disconnected) {\n                this.connectionId = null;\n                this.connectionFetchPromise = null;\n                return this.FetchConnection(requestSession);\n            } else {\n                requestSession.OnPreConnectionStart(this.authFetchEventId, this.connectionId);\n                requestSession.OnConnectionEstablishCompleted(200);\n                requestSession.ListenForServiceTelemetry(this.connectionFetchPromise.Result().Result.Events);\n                return this.connectionFetchPromise;\n            }\n        }\n\n        this.authFetchEventId = CreateNoDashGuid();\n        this.connectionId = CreateNoDashGuid();\n\n        requestSession.OnPreConnectionStart(this.authFetchEventId, this.connectionId);\n\n        const authPromise = isUnAuthorized ? this.authentication.FetchOnExpiry(this.authFetchEventId) : this.authentication.Fetch(this.authFetchEventId);\n\n        this.connectionFetchPromise = authPromise\n            .ContinueWithPromise((result: PromiseResult<AuthInfo>) => {\n                if (result.IsError) {\n                    requestSession.OnAuthCompleted(true, result.Error);\n                    throw new Error(result.Error);\n                } else {\n                    requestSession.OnAuthCompleted(false);\n                }\n\n                const connection = this.connectionFactory.Create(this.recognizerConfig, result.Result, this.connectionId);\n                requestSession.ListenForServiceTelemetry(connection.Events);\n\n                return connection.Open().OnSuccessContinueWithPromise((response: ConnectionOpenResponse) => {\n                    if (response.StatusCode === 200) {\n                        requestSession.OnConnectionEstablishCompleted(response.StatusCode);\n                        return PromiseHelper.FromResult(connection);\n                    } else if (response.StatusCode === 403 && !isUnAuthorized) {\n                        return this.FetchConnection(requestSession, true);\n                    } else {\n                        requestSession.OnConnectionEstablishCompleted(response.StatusCode, response.Reason);\n                        return PromiseHelper.FromError<IConnection>(`Unable to contact server. StatusCode: ${response.StatusCode}, Reason: ${response.Reason}`);\n                    }\n                });\n            });\n\n        return this.connectionFetchPromise;\n    }\n\n    private ReceiveMessage = (connection: IConnection, requestSession: RequestSession): Promise<boolean> => {\n        return connection\n            .Read()\n            .OnSuccessContinueWithPromise((message: ConnectionMessage) => {\n                const connectionMessage = SpeechConnectionMessage.FromConnectionMessage(message);\n                if (connectionMessage.RequestId.toLowerCase() === requestSession.RequestId.toLowerCase()) {\n                    switch (connectionMessage.Path.toLowerCase()) {\n                        case \"turn.start\":\n                            requestSession.OnServiceTurnStartResponse(JSON.parse(connectionMessage.TextBody));\n                            break;\n                        case \"speech.startDetected\":\n                            requestSession.OnServiceSpeechStartDetectedResponse(JSON.parse(connectionMessage.TextBody));\n                            break;\n                        case \"speech.hypothesis\":\n                            requestSession.OnServiceSpeechHypothesisResponse(JSON.parse(connectionMessage.TextBody));\n                            break;\n                        case \"speech.fragment\":\n                            requestSession.OnServiceSpeechFragmentResponse(JSON.parse(connectionMessage.TextBody));\n                            break;\n                        case \"speech.enddetected\":\n                            requestSession.OnServiceSpeechEndDetectedResponse(JSON.parse(connectionMessage.TextBody));\n                            break;\n                        case \"speech.phrase\":\n                            if (this.recognizerConfig.IsContinuousRecognition) {\n                                // For continuous recognition telemetry has to be sent for every phrase as per spec.\n                                this.SendTelemetryData(requestSession.RequestId, connection, requestSession.GetTelemetry());\n                            }\n                            if (this.recognizerConfig.Format === SpeechResultFormat.Simple) {\n                                requestSession.OnServiceSimpleSpeechPhraseResponse(JSON.parse(connectionMessage.TextBody));\n                            } else {\n                                requestSession.OnServiceDetailedSpeechPhraseResponse(JSON.parse(connectionMessage.TextBody));\n                            }\n                            break;\n                        case \"turn.end\":\n                            requestSession.OnServiceTurnEndResponse();\n                            return PromiseHelper.FromResult(true);\n                        default:\n                            break;\n                    }\n                }\n\n                return this.ReceiveMessage(connection, requestSession);\n            });\n    }\n\n    private SendSpeechConfig = (requestId: string, connection: IConnection, speechConfigJson: string) => {\n        if (speechConfigJson && this.connectionId !== this.speechConfigConnectionId) {\n            this.speechConfigConnectionId = this.connectionId;\n            return connection\n                .Send(new SpeechConnectionMessage(\n                    MessageType.Text,\n                    \"speech.config\",\n                    requestId,\n                    \"application/json\",\n                    speechConfigJson));\n        }\n\n        return PromiseHelper.FromResult(true);\n    }\n\n    private SendSpeechContext = (requestId: string, connection: IConnection, speechContextJson: string) => {\n        if (speechContextJson) {\n            return connection\n                .Send(new SpeechConnectionMessage(\n                    MessageType.Text,\n                    \"speech.context\",\n                    requestId,\n                    \"application/json\",\n                    speechContextJson));\n        }\n        return PromiseHelper.FromResult(true);\n    }\n\n    private SendTelemetryData = (requestId: string, connection: IConnection, telemetryData: string) => {\n        return connection\n            .Send(new SpeechConnectionMessage(\n                MessageType.Text,\n                \"telemetry\",\n                requestId,\n                \"application/json\",\n                telemetryData));\n    }\n\n    private SendAudio = (\n        requestId: string,\n        connection: IConnection,\n        audioStreamNode: IAudioStreamNode,\n        requestSession: RequestSession): Promise<boolean> => {\n            // NOTE: Home-baked promises crash ios safari during the invocation\n            // of the error callback chain (looks like the recursion is way too deep, and\n            // it blows up the stack). The following construct is a stop-gap that does not\n            // bubble the error up the callback chain and hence circumvents this problem.\n            // TODO: rewrite with ES6 promises.\n            const deferred = new Deferred<boolean>();\n\n            const imdone = (_: boolean) => {\n                deferred.Resolve(true);\n            };\n\n            const readAndUploadCycle = (_: boolean) => {\n                audioStreamNode.Read().On(\n                    (audioStreamChunk: IStreamChunk<ArrayBuffer>) => {\n                        // we have a new audio chunk to upload.\n                        if (requestSession.IsSpeechEnded) {\n                            // If service already recognized audio end then dont send any more audio\n                            deferred.Resolve(true);\n                            return;\n                        }\n\n                        const payload = (audioStreamChunk.IsEnd) ? null : audioStreamChunk.Buffer;\n                        const uploaded = connection.Send(\n                            new SpeechConnectionMessage(\n                                MessageType.Binary, \"audio\", requestId, null, payload));\n\n                        if (!audioStreamChunk.IsEnd) {\n                            // uploaded.OnSuccessContinueWith(imdone);\n                            uploaded.OnSuccessContinueWith(readAndUploadCycle);\n                        } else {\n                            // the audio stream has been closed, no need to schedule next\n                            // read-upload cycle.\n                            deferred.Resolve(true);\n                        }\n                    },\n                    (error: string) => {\n                        if (requestSession.IsSpeechEnded) {\n                            // For whatever reason, Reject is used to remove queue subscribers inside\n                            // the Queue.DrainAndDispose invoked from DetachAudioNode down blow, which\n                            // means that sometimes things can be rejected in normal circumstances, without\n                            // any errors.\n                            deferred.Resolve(true); // TODO: remove the argument, it's is completely meaningless.\n                        } else {\n                            // Only reject, if there was a proper error.\n                            deferred.Reject(error);\n                        }\n                    });\n            };\n\n            readAndUploadCycle(true);\n\n            return deferred.Promise();\n    }\n}\n\n// tslint:disable-next-line:max-classes-per-file\nclass RequestSession {\n    private isDisposed: boolean = false;\n    private serviceTelemetryListener: ServiceTelemetryListener;\n    private detachables: IDetachable[] = new Array<IDetachable>();\n    private requestId: string;\n    private audioSourceId: string;\n    private audioNodeId: string;\n    private audioNode: IAudioStreamNode;\n    private authFetchEventId: string;\n    private connectionId: string;\n    private serviceTag: string;\n    private isAudioNodeDetached: boolean = false;\n    private isCompleted: boolean = false;\n    private onEventCallback: (event: SpeechRecognitionEvent) => void;\n\n    private requestCompletionDeferral: Deferred<boolean>;\n\n    constructor(audioSourceId: string, onEventCallback: (event: SpeechRecognitionEvent) => void) {\n        this.audioSourceId = audioSourceId;\n        this.onEventCallback = onEventCallback;\n        this.requestId = CreateNoDashGuid();\n        this.audioNodeId = CreateNoDashGuid();\n        this.requestCompletionDeferral = new Deferred<boolean>();\n\n        this.serviceTelemetryListener = new ServiceTelemetryListener(this.requestId, this.audioSourceId, this.audioNodeId);\n\n        this.OnEvent(new RecognitionTriggeredEvent(this.RequestId, this.audioSourceId, this.audioNodeId));\n    }\n\n    public get RequestId(): string {\n        return this.requestId;\n    }\n\n    public get AudioNodeId(): string {\n        return this.audioNodeId;\n    }\n\n    public get CompletionPromise(): Promise<boolean> {\n        return this.requestCompletionDeferral.Promise();\n    }\n\n    public get IsSpeechEnded(): boolean {\n        return this.isAudioNodeDetached;\n    }\n\n    public get IsCompleted(): boolean {\n        return this.isCompleted;\n    }\n\n    public ListenForServiceTelemetry(eventSource: IEventSource<PlatformEvent>): void {\n        this.detachables.push(eventSource.AttachListener(this.serviceTelemetryListener));\n    }\n\n    public OnAudioSourceAttachCompleted = (audioNode: IAudioStreamNode, isError: boolean, error?: string): void => {\n        this.audioNode = audioNode;\n        if (isError) {\n            this.OnComplete(RecognitionCompletionStatus.AudioSourceError, error);\n        } else {\n            this.OnEvent(new ListeningStartedEvent(this.requestId, this.audioSourceId, this.audioNodeId));\n        }\n    }\n\n    public OnPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\n        this.authFetchEventId = authFetchEventId;\n        this.connectionId = connectionId;\n        this.OnEvent(new ConnectingToServiceEvent(this.requestId, this.authFetchEventId, this.connectionId));\n    }\n\n    public OnAuthCompleted = (isError: boolean, error?: string): void => {\n        if (isError) {\n            this.OnComplete(RecognitionCompletionStatus.AuthTokenFetchError, error);\n        }\n    }\n\n    public OnConnectionEstablishCompleted = (statusCode: number, reason?: string): void => {\n        if (statusCode === 200) {\n            this.OnEvent(new RecognitionStartedEvent(this.RequestId, this.audioSourceId, this.audioNodeId, this.authFetchEventId, this.connectionId));\n            return;\n        } else if (statusCode === 403) {\n            this.OnComplete(RecognitionCompletionStatus.UnAuthorized, reason);\n        } else {\n            this.OnComplete(RecognitionCompletionStatus.ConnectError, reason);\n        }\n    }\n\n    public OnServiceTurnStartResponse = (response: ITurnStartResponse): void => {\n        if (response && response.context && response.context.serviceTag) {\n            this.serviceTag = response.context.serviceTag;\n        }\n    }\n\n    public OnServiceSpeechStartDetectedResponse = (result: ISpeechStartDetectedResult): void => {\n        this.OnEvent(new SpeechStartDetectedEvent(this.RequestId, result));\n    }\n\n    public OnServiceSpeechHypothesisResponse = (result: ISpeechFragment): void => {\n        this.OnEvent(new SpeechHypothesisEvent(this.RequestId, result));\n    }\n\n    public OnServiceSpeechFragmentResponse = (result: ISpeechFragment): void => {\n        this.OnEvent(new SpeechFragmentEvent(this.RequestId, result));\n    }\n\n    public OnServiceSpeechEndDetectedResponse = (result: ISpeechEndDetectedResult): void => {\n        this.DetachAudioNode();\n        this.OnEvent(new SpeechEndDetectedEvent(this.RequestId, result));\n    }\n\n    public OnServiceSimpleSpeechPhraseResponse = (result: ISimpleSpeechPhrase): void => {\n        this.OnEvent(new SpeechSimplePhraseEvent(this.RequestId, result));\n    }\n\n    public OnServiceDetailedSpeechPhraseResponse = (result: IDetailedSpeechPhrase): void => {\n        this.OnEvent(new SpeechDetailedPhraseEvent(this.RequestId, result));\n    }\n\n    public OnServiceTurnEndResponse = (): void => {\n        this.OnComplete(RecognitionCompletionStatus.Success);\n    }\n\n    public OnConnectionError = (error: string): void => {\n        this.OnComplete(RecognitionCompletionStatus.UnknownError, error);\n    }\n\n    public Dispose = (error?: string): void => {\n        if (!this.isDisposed) {\n            // we should have completed by now. If we did not its an unknown error.\n            this.OnComplete(RecognitionCompletionStatus.UnknownError, error);\n            this.isDisposed = true;\n            for (const detachable of this.detachables) {\n                detachable.Detach();\n            }\n\n            this.serviceTelemetryListener.Dispose();\n        }\n    }\n\n    public GetTelemetry = (): string => {\n        return this.serviceTelemetryListener.GetTelemetry();\n    }\n\n    private OnComplete = (status: RecognitionCompletionStatus, error?: string): void => {\n        if (!this.isCompleted) {\n            this.isCompleted = true;\n            this.DetachAudioNode();\n            this.OnEvent(new RecognitionEndedEvent(this.RequestId, this.audioSourceId, this.audioNodeId, this.authFetchEventId, this.connectionId, this.serviceTag, status, error ? error : \"\"));\n        }\n    }\n\n    private DetachAudioNode = (): void => {\n        if (!this.isAudioNodeDetached) {\n            this.isAudioNodeDetached = true;\n            if (this.audioNode) {\n                this.audioNode.Detach();\n            }\n        }\n    }\n\n    private OnEvent = (event: SpeechRecognitionEvent): void => {\n        this.serviceTelemetryListener.OnEvent(event);\n        Events.Instance.OnEvent(event);\n        if (this.onEventCallback) {\n            this.onEventCallback(event);\n        }\n    }\n}\n\ninterface ITurnStartResponse {\n    context: ITurnStartContext;\n}\n\ninterface ITurnStartContext {\n    serviceTag: string;\n}\n"]}